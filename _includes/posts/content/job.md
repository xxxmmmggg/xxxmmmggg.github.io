### 操作系统

#### 1. 线程与进程区别
进程是程序的一次执行，是系统进行资源分配和调度的基本单位。   
线程是进程的实体，是CPU进行调度和分配的最小单位。    
各个进程是独立的，独立的进程空间、上下文环境。线程属于进程，一个进程可以有多个线程。多个线程共享进程空间。   

#### 2. 线程/进程同步方式、进程通信方式
线程/进程同步方式：临界区、互斥量、信号量、事件。临界区主要是同一进程内的线程同步，互斥量可以跨进程同步。      
进程通信的方式有：信号、信号量、消息队列、共享内存、SOCKET。          

#### 3. 缓冲区溢出？原因是什么？有什么危害？
缓冲区溢出：程序在写数据到缓冲区时，写入缓冲区的数据超过了缓冲区容量，溢出的数据覆盖了合法的数据。            
缓冲区溢出的危害：程序崩溃、执行一段恶意代码。  
造成缓冲区溢出的原因是程序没有检查用户的输入。         

#### 4. 死锁？死锁产生的条件？解除死锁的方法？
在两个或多个并发线程中，每个线程持有某种资源且又等待其他线程持有的资源。在未改变这种状态前，这组进程无法推进，造成死锁。通俗的讲就是进程之间互相阻塞有互相等待的状态。    
产生死锁的条件：互斥条件（一个资源只能被一个进程占有）；请求并保持(进程对请求的资源保持不放)； 不可剥夺（进程请求的资源不能被强制剥夺）； 循环等待（进程之间形成环形的资源等待关系）。   
解除死锁的方法（破坏产生死锁的条件）：    
1：预防死锁：资源一次性分配（破坏请求和保持条件）、资源有序分配（破坏循环等待）、资源可剥夺（破坏不可剥夺）。         
2：避免死锁：避免死锁的算法：银行家算法。      
3：检测死锁：建立资源分配表和进程等待资源表。     
4：解除死锁：剥夺资源、撤销进程。       

#### 5. 进程有哪几种状态及其互相转换
进程有执行、就绪、阻塞三种状态。            
阻塞转为就绪：阻塞的进程获得资源，转为就绪。          
就绪转为执行：就绪的进程被调度。    
执行转为就绪：执行的进程因时间片到等事件转为就绪。    
执行转为阻塞：执行的进程因需要获得某资源等事件转换为阻塞状态。     

#### 6.操作系统调度进程的方式
先来先服务、时间片到、优先级

#### 7.分段和分页的区别
段是信息的逻辑单位，根据用户的需要划分，对用户可见。页是信息的物理单位，方便内存管理，对用户透明。段的大小不固定，由用户决定。页的大小是固定的，由操作系统决定。       

---
### 网络
懒加载与懒实例化剩下的路由对于 SPA 是一件相对麻烦点儿的事情，你需要实现基于路由的 code splitting 与异步加载。幸运的是，这又是一件不需要多页应用担心的事情，多页应用中的各个路由天生就是分离的。

值得说明的是，无论单页还是多页应用，如果在上一步中，我们已经将这些路由的资源都预先下载与缓存好了，那么懒加载就几乎是瞬时完成的了，这时候我们就只需要付出实例化的代价。

---
### 数据库
懒加载与懒实例化剩下的路由对于 SPA 是一件相对麻烦点儿的事情，你需要实现基于路由的 code splitting 与异步加载。幸运的是，这又是一件不需要多页应用担心的事情，多页应用中的各个路由天生就是分离的。

值得说明的是，无论单页还是多页应用，如果在上一步中，我们已经将这些路由的资源都预先下载与缓存好了，那么懒加载就几乎是瞬时完成的了，这时候我们就只需要付出实例化的代价。

---
### 4. LAZY-LOAD 按需懒加载、懒实例化剩下的路由
懒加载与懒实例化剩下的路由对于 SPA 是一件相对麻烦点儿的事情，你需要实现基于路由的 code splitting 与异步加载。幸运的是，这又是一件不需要多页应用担心的事情，多页应用中的各个路由天生就是分离的。

值得说明的是，无论单页还是多页应用，如果在上一步中，我们已经将这些路由的资源都预先下载与缓存好了，那么懒加载就几乎是瞬时完成的了，这时候我们就只需要付出实例化的代价。

---